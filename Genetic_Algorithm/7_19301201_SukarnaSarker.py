# -*- coding: utf-8 -*-
"""Untitled13.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1uSvzDdQj7ljEltwVBa5hVQh4prcbtvqA
"""

import random
import math

iteration = 1
def generate_initial_population(tot_num_of_transactions, population_size):
 population=[]
 for i in range(0,population_size):
   value=""
   for j in range(0,tot_num_of_transactions):
     population1=str(random.randint(0,1))
     value=value+population1
   population.append(value)  
 return population 

def fitness_function(individual, trans_lst):
  fittnessvalue=[]
  individuallist=[]
  sum = 0
  individuallist = [int(i) for i in str(individual)]
  for i in range(0,len(individuallist)):
    if(individuallist[i]==1):
      sum=sum+trans_lst[i]     
  fittnessvalue.append(sum)
  return fittnessvalue

def crossover(s_1, s_2, length):
  value1=random.randint(0,length-1)
  crover=s_1[:value1]+s_2[value1:]
  return crover

def mutation(s_current,length):
  whichone=random.randint(0,length-1)
  v1=""
  if(s_current[whichone]=="0"):
    v1="1"
  elif(s_current[whichone]=="1"):
    v1="0"
  s_current=s_current[:whichone]+v1+s_current[whichone+1:]   
  return s_current

def clone_N_individuals(sorted_s):
  return sorted_s


def genetic_algorithm(trans_lst, s, s_best, population_size, iterations_number, crossover_rate, mutation_rate, cloning_rate):
  global iteration

  if fitness_function(s_best, trans_lst) == 0:  # Recursion Termination Condition
    return s_best
  if iteration == iterations_number:
    return s_best 
  new_s = []
  s1=random.randint(0,len(s)-1)
  s2=random.randint(0,len(s)-1)
  for i in range(0,int(population_size*crossover_rate)):
    S__1=s[s1]
    S__2=s[s2]
    cross=crossover(S__1,S__2,len(s))  
    new_s.append(cross)    

  for j in range(0,int((population_size*(crossover_rate + mutation_rate)) - (population_size*crossover_rate))):
    mute=mutation(s[j],n) 
    new_s.append(mute)


  for j in range(0,int(population_size*(crossover_rate + mutation_rate + cloning_rate) - (population_size*(crossover_rate + mutation_rate)))):
    clone=clone_N_individuals(s_best)
    new_s.append(clone)

  new=[]   

  
  for i in range(0,len(new_s)):
    value1=fitness_function(new_s[i], trans_lst)
    new.append(value1)
  s1 = [x for _,x in sorted(zip(new,z))]
  new=s1

  s_best=new[0]
  iteration += 1
  return genetic_algorithm(trans_lst, new_s, s_best, population_size, iterations_number, crossover_rate, mutation_rate,cloning_rate)

    

  


    # Sort new_s according to the individuals' fitness score

    # if the fitness score of new_s[0] is closer to 0 than the fitness score of current "s_best",
    # assign the value of new_s[0] to s_best

fl = open("input.txt","r")
n = int(fl.readline())
trans_lst = [] 
elements = []
l1 = []
for l1 in fl:               
  for word in l1.split():   
    elements.append(word)    

for i in range(0,len(elements)):
  if(elements[i]=="l"):
    a=-1*int(elements[i+1])
    trans_lst.append(a)
  elif(elements[i]=="d"):
    b=int(elements[i+1])
    trans_lst.append(b)     


## Hyperparameters
population_size = 10
iterations_number = 700
## The following hyper parameters should sum up to 1
crossover_rate = 0.8
mutation_rate = 0.10
cloning_rate = 0.10

Z = []
fit=[]
s=[]
z=generate_initial_population(n,population_size)
for i in range(0,len(z)):
  value=fitness_function(z[i], trans_lst)
  fit.append(value)
S = [x for _,x in sorted(zip(fit,z))]
s=S

s_final = genetic_algorithm(trans_lst, s, s[0], population_size, iterations_number, crossover_rate, mutation_rate, cloning_rate)


if(fitness_function(s_final,trans_lst) == 0):
  print(s_final)
else:
  print("-1")